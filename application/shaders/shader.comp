#version 450
#extension GL_ARB_separate_shader_objects:enable
#extension GL_EXT_nonuniform_qualifier:enable

layout (local_size_x = 32) in;

layout(set = 0, binding = 0) buffer BindlessBuffer{
    uint data[];
} inputData[];

layout(push_constant) uniform constant{
    uint imageid;
} pushConstant;

uint imageCnt(){
    return inputData[0].data[0];
}

struct Cluster{
    vec4 lodBounds;
    vec4 parentLodBounds;
    float lodError;
    float maxParentLodError;
};

struct FrameContext{
    mat4 mvp;
    mat4 view;
};

Cluster GetCluster(uint clusterId){
	Cluster cluster;
	uint idx = 1 + 3 * imageCnt();
    uint offset = 4 + 16 * clusterId;

	cluster.lodBounds.x         = uintBitsToFloat(inputData[idx].data[offset + 4]);
	cluster.lodBounds.y         = uintBitsToFloat(inputData[idx].data[offset + 5]);
	cluster.lodBounds.z         = uintBitsToFloat(inputData[idx].data[offset + 6]);
	cluster.lodBounds.w         = uintBitsToFloat(inputData[idx].data[offset + 7]);

	cluster.parentLodBounds.x   = uintBitsToFloat(inputData[idx].data[offset + 8]);
	cluster.parentLodBounds.y   = uintBitsToFloat(inputData[idx].data[offset + 9]);
	cluster.parentLodBounds.z   = uintBitsToFloat(inputData[idx].data[offset + 10]);
	cluster.parentLodBounds.w   = uintBitsToFloat(inputData[idx].data[offset + 11]);

    cluster.lodError            = uintBitsToFloat(inputData[idx].data[offset + 12]);
    cluster.maxParentLodError   = uintBitsToFloat(inputData[idx].data[offset + 13]);

	return cluster;
}

FrameContext GetFrameContext(){
	uint idx = pushConstant.imageid + 1 + 2 * imageCnt();
	FrameContext context;
	for(int i = 0; i < 4; i++){
		vec4 p;
		p.x = uintBitsToFloat(inputData[idx].data[i * 4]);
		p.y = uintBitsToFloat(inputData[idx].data[i * 4 + 1]);
		p.z = uintBitsToFloat(inputData[idx].data[i * 4 + 2]);
		p.w = uintBitsToFloat(inputData[idx].data[i * 4 + 3]);
		context.mvp[i] = p;
	}
	
	for(int i = 0; i < 4; i++){
		vec4 p;
		p.x = uintBitsToFloat(inputData[idx].data[i * 4 + 16]);
		p.y = uintBitsToFloat(inputData[idx].data[i * 4 + 1 + 16]);
		p.z = uintBitsToFloat(inputData[idx].data[i * 4 + 2 + 16]);
		p.w = uintBitsToFloat(inputData[idx].data[i * 4 + 3 + 16]);
		context.view[i] = p;
	}

	return context;
}

uint GetClustersNum(){
    uint idx = 1 + 3 * imageCnt();
    return inputData[idx].data[0];
}


void InitArguments(){
    uint id = pushConstant.imageid + 1;
    inputData[id].data[0] = 128 * 3;
    inputData[id].data[1] = 0;
    inputData[id].data[2] = 0;
    inputData[id].data[3] = 0;
}


bool CheckLod(mat4 view, vec4 bound, float error){
    vec3 p = (view * vec4(bound.xyz, 1.0)).xyz;
    float d = max(length(p) - bound.w, 0);
    float theta = radians(40) / 1080.0f;
    return theta * d >= error;
}

void AddCluster(uint clusterId){
    uint visilityBufferId = pushConstant.imageid + 1 + imageCnt();          // visibility buffer
    uint indirectBufferId = pushConstant.imageid + 1;                       // indirect buffer
    uint pos = atomicAdd(inputData[indirectBufferId].data[1], 1);
    inputData[visilityBufferId].data[pos] = clusterId;
}

void main(){
    uint clusterId = gl_GlobalInvocationID.x;
    uint clusterNum = GetClustersNum();

    if(clusterId == 0){
        InitArguments();
    }

    barrier();

    if(clusterId < clusterNum){
        Cluster cluster = GetCluster(clusterId);
        FrameContext context = GetFrameContext();

        bool parentCheck = CheckLod(context.view, cluster.parentLodBounds, cluster.maxParentLodError);
        bool clusterCheck = CheckLod(context.view, cluster.lodBounds, cluster.lodError);
        if(!parentCheck && clusterCheck){
            AddCluster(clusterId);
        }
    }
}